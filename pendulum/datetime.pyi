# Stubs for pendulum.datetime (Python 3.7)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

import datetime
from .constants import (
    ATOM,
    COOKIE,
    MINUTES_PER_HOUR,
    MONTHS_PER_YEAR,
    RFC1036,
    RFC1123,
    RFC2822,
    RFC822,
    RFC850,
    RSS,
    SATURDAY,
    SECONDS_PER_DAY,
    SECONDS_PER_MINUTE,
    SUNDAY,
    W3C,
    YEARS_PER_CENTURY,
    YEARS_PER_DECADE,
)
from .date import Date
from .exceptions import PendulumException
from .helpers import add_duration, timestamp
from .period import Period
from .time import Time
from .tz import UTC
from .tz.timezone import Timezone
from .utils._compat import _HAS_FOLD
from typing import Any, Optional, TypeVar, Union

_D = TypeVar("_D", bound="DateTime")

class DateTime(datetime.datetime, Date):  # type: ignore
    EPOCH: DateTime = ...
    def __new__(
        cls,
        year: Any,
        month: Any,
        day: Any,
        hour: int = ...,
        minute: int = ...,
        second: int = ...,
        microsecond: int = ...,
        tzinfo: Optional[Any] = ...,
        fold: int = ...,
    ): ...
    @classmethod
    def now(  # type: ignore
        cls: Any, tz: Optional[Union[str, Timezone]] = ...
    ) -> DateTime: ...
    @classmethod
    def utcnow(cls: Any) -> DateTime: ...
    @classmethod
    def today(cls: Any) -> DateTime: ...
    @classmethod
    def strptime(cls: Any, time: str, fmt: str) -> DateTime: ...
    def set(
        self,
        year: Optional[Any] = ...,
        month: Optional[Any] = ...,
        day: Optional[Any] = ...,
        hour: Optional[Any] = ...,
        minute: Optional[Any] = ...,
        second: Optional[Any] = ...,
        microsecond: Optional[Any] = ...,
        tz: Optional[Any] = ...,
    ): ...
    @property
    def fold(self): ...
    def timestamp(self): ...
    @property
    def float_timestamp(self): ...
    @property
    def int_timestamp(self): ...
    @property
    def offset(self): ...
    @property
    def offset_hours(self): ...
    @property
    def timezone(self) -> Optional[Timezone]: ...
    @property
    def tz(self) -> Optional[Timezone]: ...
    @property
    def timezone_name(self) -> Optional[str]: ...
    @property
    def age(self): ...
    def is_local(self): ...
    def is_utc(self): ...
    def is_dst(self): ...
    def get_offset(self): ...
    def date(self): ...
    def time(self): ...
    def naive(self) -> _D: ...
    def on(self, year: Any, month: Any, day: Any): ...
    def at(
        self, hour: Any, minute: int = ..., second: int = ..., microsecond: int = ...
    ): ...
    def in_timezone(self, tz: Union[str, Timezone]) -> DateTime: ...
    def in_tz(self, tz: Union[str, Timezone]) -> DateTime: ...
    def to_time_string(self): ...
    def to_datetime_string(self): ...
    def to_day_datetime_string(self): ...
    def to_atom_string(self): ...
    def to_cookie_string(self): ...
    def to_iso8601_string(self): ...
    def to_rfc822_string(self): ...
    def to_rfc850_string(self): ...
    def to_rfc1036_string(self): ...
    def to_rfc1123_string(self): ...
    def to_rfc2822_string(self): ...
    def to_rfc3339_string(self): ...
    def to_rss_string(self): ...
    def to_w3c_string(self): ...
    def closest(self, dt1: Any, dt2: Any, *dts: Any): ...
    def farthest(self, dt1: Any, dt2: Any, *dts: Any): ...
    def is_future(self): ...
    def is_past(self): ...
    def is_long_year(self): ...
    def is_same_day(self, dt: Any): ...
    def is_birthday(self, dt: Optional[Any] = ...): ...
    def add(
        self,
        years: int = ...,
        months: int = ...,
        weeks: int = ...,
        days: int = ...,
        hours: int = ...,
        minutes: int = ...,
        seconds: int = ...,
        microseconds: int = ...,
    ) -> _D: ...
    def subtract(
        self,
        years: int = ...,
        months: int = ...,
        weeks: int = ...,
        days: int = ...,
        hours: int = ...,
        minutes: int = ...,
        seconds: int = ...,
        microseconds: int = ...,
    ): ...
    def diff(self, dt: Optional[Any] = ..., abs: bool = ...): ...
    def diff_for_humans(
        self,
        other: Optional[DateTime] = ...,
        absolute: bool = ...,
        locale: Optional[str] = ...,
    ) -> str: ...
    def start_of(self, unit: Any): ...
    def end_of(self, unit: Any): ...
    def next(self, day_of_week: Optional[Any] = ..., keep_time: bool = ...): ...
    def previous(self, day_of_week: Optional[Any] = ..., keep_time: bool = ...): ...
    def first_of(self, unit: Any, day_of_week: Optional[Any] = ...): ...
    def last_of(self, unit: Any, day_of_week: Optional[Any] = ...): ...
    def nth_of(self, unit: Any, nth: Any, day_of_week: Any): ...
    def average(self, dt: Optional[Any] = ...): ...
    def __sub__(self, other: Any): ...
    def __rsub__(self, other: Any): ...
    def __add__(self, other: Any): ...
    def __radd__(self, other: Any): ...
    @classmethod
    def fromtimestamp(cls, t: Any, tz: Optional[Any] = ...): ...
    @classmethod
    def utcfromtimestamp(cls, t: Any): ...
    @classmethod
    def fromordinal(cls, n: Any): ...
    @classmethod
    def combine(cls, date: Any, time: Any): ...  # type: ignore
    def astimezone(self, tz: Optional[Any] = ...): ...
    def replace(  # type: ignore
        self,
        year: Optional[Any] = ...,
        month: Optional[Any] = ...,
        day: Optional[Any] = ...,
        hour: Optional[Any] = ...,
        minute: Optional[Any] = ...,
        second: Optional[Any] = ...,
        microsecond: Optional[Any] = ...,
        tzinfo: bool = ...,
        fold: Optional[Any] = ...,
    ): ...
    def __getnewargs__(self): ...
    def __reduce__(self): ...
    def __reduce_ex__(self, protocol: Any): ...
