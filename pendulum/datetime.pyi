# Stubs for pendulum.datetime (Python 3.7)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import overload
import datetime
from .constants import (
    ATOM,
    COOKIE,
    MINUTES_PER_HOUR,
    MONTHS_PER_YEAR,
    RFC1036,
    RFC1123,
    RFC2822,
    RFC822,
    RFC850,
    RSS,
    SATURDAY,
    SECONDS_PER_DAY,
    SECONDS_PER_MINUTE,
    SUNDAY,
    W3C,
    YEARS_PER_CENTURY,
    YEARS_PER_DECADE,
)
from .date import Date
from .exceptions import PendulumException
from .helpers import add_duration, timestamp
from .period import Period
from .time import Time
from .tz import UTC
from .tz.timezone import Timezone
from .utils._compat import _HAS_FOLD
from typing import Any, Optional, TypeVar, Union

from datetime import tzinfo as _tzinfo

_D = TypeVar("_D", bound="DateTime")

class DateTime(datetime.datetime, Date):  # type: ignore
    EPOCH: DateTime = ...
    def __new__(
        cls,
        year: int,
        month: int,
        day: int,
        hour: int = ...,
        minute: int = ...,
        second: int = ...,
        microsecond: int = ...,
        tzinfo: Optional[_tzinfo] = ...,
        fold: int = ...,
    ): ...
    @classmethod
    def now(cls, tz: Union[str, Timezone, _tzinfo, None] = ...) -> DateTime: ...
    @classmethod
    def utcnow(cls: Any) -> DateTime: ...
    @classmethod
    def today(cls: Any) -> DateTime: ...
    @classmethod
    def strptime(cls, time: str, fmt: str) -> DateTime: ...
    def set(
        self,
        year: Optional[int] = ...,
        month: Optional[int] = ...,
        day: Optional[int] = ...,
        hour: Optional[int] = ...,
        minute: Optional[int] = ...,
        second: Optional[int] = ...,
        microsecond: Optional[int] = ...,
        tz: Optional[int] = ...,
    ) -> DateTime: ...
    @property
    def fold(self) -> int: ...
    def timestamp(self) -> float: ...
    @property
    def float_timestamp(self) -> float: ...
    @property
    def int_timestamp(self) -> int: ...
    @property
    def offset(self): ...
    @property
    def offset_hours(self) -> float: ...
    @property
    def timezone(self) -> Optional[Timezone]: ...
    @property
    def tz(self) -> Optional[Timezone]: ...
    @property
    def timezone_name(self) -> Optional[str]: ...
    @property
    def age(self) -> float: ...
    def is_local(self) -> bool: ...
    def is_utc(self) -> bool: ...
    def is_dst(self) -> bool: ...
    def get_offset(self) -> bool: ...
    def date(self) -> Date: ...
    def time(self) -> Time: ...
    def naive(self) -> DateTime: ...
    def on(self, year: float, month: float, day: float) -> DateTime: ...
    def at(
        self, hour: int, minute: int = ..., second: int = ..., microsecond: int = ...
    ) -> DateTime: ...
    def in_timezone(self, tz: Union[str, Timezone]) -> DateTime: ...
    def in_tz(self, tz: Union[str, Timezone]) -> DateTime: ...
    def to_time_string(self) -> str: ...
    def to_datetime_string(self) -> str: ...
    def to_day_datetime_string(self) -> str: ...
    def to_atom_string(self) -> str: ...
    def to_cookie_string(self) -> str: ...
    def to_iso8601_string(self) -> str: ...
    def to_rfc822_string(self) -> str: ...
    def to_rfc850_string(self) -> str: ...
    def to_rfc1036_string(self) -> str: ...
    def to_rfc1123_string(self) -> str: ...
    def to_rfc2822_string(self) -> str: ...
    def to_rfc3339_string(self) -> str: ...
    def to_rss_string(self) -> str: ...
    def to_w3c_string(self) -> str: ...
    def closest(
        self, dt1: datetime.datetime, dt2: datetime.datetime, *dts: datetime.datetime
    ) -> DateTime: ...
    def farthest(
        self, dt1: datetime.datetime, dt2: datetime.datetime, *dts: datetime.datetime
    ) -> DateTime: ...
    def is_future(self) -> bool: ...
    def is_past(self) -> bool: ...
    def is_long_year(self) -> bool: ...
    def is_same_day(self, dt: Any) -> bool: ...
    def is_birthday(self, dt: Optional[Any] = ...) -> bool: ...
    def add(
        self: _D,
        years: int = ...,
        months: int = ...,
        weeks: int = ...,
        days: int = ...,
        hours: int = ...,
        minutes: int = ...,
        seconds: int = ...,
        microseconds: int = ...,
    ) -> _D: ...
    def subtract(
        self: _D,
        years: int = ...,
        months: int = ...,
        weeks: int = ...,
        days: int = ...,
        hours: int = ...,
        minutes: int = ...,
        seconds: int = ...,
        microseconds: int = ...,
    ) -> _D: ...
    def diff(self, dt: Optional[DateTime] = ..., abs: bool = ...) -> Period: ...
    def diff_for_humans(
        self,
        other: Optional[DateTime] = ...,
        absolute: bool = ...,
        locale: Optional[str] = ...,
    ) -> str: ...
    def start_of(self, unit: str) -> DateTime: ...
    def end_of(self, unit: str) -> DateTime: ...
    def next(
        self, day_of_week: Optional[int] = ..., keep_time: bool = ...
    ) -> DateTime: ...
    def previous(
        self, day_of_week: Optional[int] = ..., keep_time: bool = ...
    ) -> DateTime: ...
    def first_of(self, unit: str, day_of_week: Optional[int] = ...) -> DateTime: ...
    def last_of(self, unit: str, day_of_week: Optional[int] = ...) -> DateTime: ...
    def nth_of(self, unit: str, nth: int, day_of_week: Optional[int]) -> DateTime: ...
    def average(self: _D, dt: Optional[datetime.datetime] = ...) -> _D: ...
    @overload  # type: ignore
    def __sub__(self, other: datetime.timedelta) -> Date: ...
    @overload
    def __sub__(self, other: Date) -> Period: ...
    def __rsub__(self, other: Any): ...
    def __add__(self, other: Any): ...
    def __radd__(self, other: Any): ...
    @classmethod
    def fromtimestamp(cls, t: Any, tz: Optional[Any] = ...): ...
    @classmethod
    def utcfromtimestamp(cls, t: Any): ...
    @classmethod
    def fromordinal(cls, n: Any): ...
    @classmethod
    def combine(cls, date: Any, time: Any): ...  # type: ignore
    def astimezone(self, tz: Optional[Any] = ...): ...
    def replace(  # type: ignore
        self,
        year: Optional[Any] = ...,
        month: Optional[Any] = ...,
        day: Optional[Any] = ...,
        hour: Optional[Any] = ...,
        minute: Optional[Any] = ...,
        second: Optional[Any] = ...,
        microsecond: Optional[Any] = ...,
        tzinfo: bool = ...,
        fold: Optional[Any] = ...,
    ): ...
    def __getnewargs__(self): ...
    def __reduce__(self): ...
    def __reduce_ex__(self, protocol: Any): ...
